<!doctype html>
<html>
    <head>
        <title>Raycaster API</title>
        <style>
            .macro{
            }
            .macro hr{
                border-style: solid;
                border-color: black;
                border-width: 1px;
            }
            h2{
                font-size: medium;
                font-weight: bold;
            }
            h1{
                margin: 0%;
            }
            code{
                margin: 0%;
            }
        </style>
    </head>

    <body>
        <section class="macro">
            <dl>
                <h1><code>uint8_t initializeEngine(uint8_t *map, int mapRowSize, uint8_t **tilemap, enum DrawMode mode)</code></h1>
                <p>This sets up some initial values and loads needed data for the raycaster. This should be called before any other raycaster functions.</p>
                <h2><dt>Parameters</dt></h2>
                <dd><table>
                    <tr>
                        <th>uint8_t *map</th>
                        <td>-</td>
                        <td>A pointer the the map data where 0 represents no wall and any other 8 bit value corresponds to a sprite in the tilemap or pallet color if sprites are not being used.</td>
                    </tr>
                    <tr>
                        <th>int mapRowSize</th>
                        <td>-</td>
                        <td>The number of elements in each row of the map. This would be the second value in a 2d array.</td>
                    </tr>
                    <tr>
                        <th>uint8_t **tilemap</th>
                        <td>-</td>
                        <td>A pointer to a tilemap of square sprites which should be rotated 90 degrees clockwise of how it should be displayed. This can be null if sprites are not being used.</td>
                    </tr>
                    <tr>
                        <th>enum DrawMode mode</th>
                        <td>-</td>
                        <td>The drawing mode of the engine either 'textured' for sprite based walls or 'line' for color based walls</td>
                    </tr>
                </table></dd>
                <h2><dt>Return Value</dt></h2>
                <dd>Returns 0 if sucessful and a different uint8_t value if something failed</dd>
                <h2><dt>Notes</dt></h2>
                <dd>This will attempt to load an appvar with data the raycaster depends on, or will attempt to create it if it cannot be opened. If a new appvar is created there may be </dd>
           
            </dl>
            <hr>

            <dl>
                <h1><code>void setScreen(int windowX, int windowY, int windowWidth, int windowHeight, uint8_t bpp, int fov)</code></h1>
                <p>This sets the area for the raycaster to draw to and should be called atleast once before the screen is cast for the first time then can be called again at anytime to change the screen area.</p>
                <h2><dt>Parameters</dt></h2>
                <dd><table>
                    <tr>
                        <th>int windowX</th>
                        <td>-</td>
                        <td>An integer value for the X offset of the render area compared to the LCD. A positive values moves right, negative left. There is no bounds checking and should be done manually by setting windowWidth accordingly. This should not be greater than 320 without good reason.</td>
                    </tr>

                    <tr>
                        <th>int windowY</th>
                        <td>-</td>
                        <td>An integer value for the Y offset of the render area compared to the LCD. A positive values moves down, negative up. There is no bounds checking and should be done manually by setting windowHeight accordingly. This should not be greater than 240 without good reason.</td>
                    </tr>

                    <tr>
                        <th>int windowWidth</th>
                        <td>-</td>
                        <td>An integer value for the width of the window. This will automatically be adjusted for different bpp states so 320 will always appear to by the full width of the lcd. This should not be greater than 320-windowX without good reason.</td>
                    </tr>

                    <tr>
                        <th>int windowHeight</th>
                        <td>-</td>
                        <td>An integer value for the height of the window. 240 will always appear to by the full height of the lcd. This should not be greater than 240-windowY without good reason.</td>
                    </tr>
                    
                    <tr>
                        <th>uint8_t bpp</th>
                        <td>-</td>
                        <td>The bit per pixel mode of the screen (8, 4, 2, 1). This should probably be 8 if the graphx library is used. For values other than 8 walls will be rendered at half resolution</td>
                    </tr>

                    <tr>
                        <th>int fov</th>
                        <td>-</td>
                        <td>The field of view in degrees, can be any integer 0-FOV_LIMIT</td>
                    </tr>
                </table></dd>
                <h2><dt>Notes</dt></h2>
                <dd>There will be little to no checks to ensure you are no drawing to random/invalide memory locations. All values are expected to be valid and will be treated as such, anytime this is not true may result in undefined behavior.</dd>
            </dl>
            <hr>
            <dl>
                <h1><code>void castScreen(int playerX, int playerY, int playerDirection)</code></h1>
                <p>This casts the entire screen based on position and state of the raycaster values drawing all walls in view</p>
                <h2><dt>Parameters</dt></h2>
                <dd><table>
                    <tr>
                        <th>int playerX</th>
                        <td>-</td>
                        <td>An integer value for the X position to cast the screen from ie where the player/camera is standing. This is in 8.8 fix point format so the bottom 8 bits represents position within a tile and top 8 bits represent the tile within the map</td>
                    </tr>

                    <tr>
                        <th>int playerY</th>
                        <td>-</td>
                        <td>An integer value for the Y position to cast the screen from ie where the player/camera is standing. Values should be in the same format as playerX</td>
                    </tr>

                    <tr>
                        <th>int playerDirection</th>
                        <td>-</td>
                        <td>An integer value for the direction to cast the screen from ie where the player/camera is looking. This should be a value between 0-360*ANGLE_MULTIPLIER</td>
                    </tr>
                </table></dd>
                <h2><dt>Notes</dt></h2>
                <dd>The position can be converted from a floating point representation by multiplying by 0x100 or 256 and rounding.</dd>
                <dd>The angle of the direction is also a fixed point format by instead of 8.8 it is dependant on the ANGLE_MULTIPLIER macro. This means it can be treated the same as playerX/Y but when converting from float multiply by ANGLE_MULTIPLIER instead of 0x100</dd>
            </dl>
            <hr>
            
            <h1><code>void changeTilemap(uint8_t **tilemap)</code></h1>
            <p>Changes the tilemap used by the raycaster</p>
            <h2><dt>Parameters</dt></h2>
            <dd><table>
                <tr>
                    <th>uint8_t **tilemap</th>
                    <td>-</td>
                    <td>Pointer to the new tilemap</td>
                </tr>
            </table></dd>
            <hr>

            <h1><code>void changeDrawMode(enum DrawMode Mode)</code></h1>
            <p>Changes the draw mode of the raycaster</p>
            <h2><dt>Parameters</dt></h2>
            <dd><table>
                <tr>
                    <th>uint8_t **tilemap</th>
                    <td>-</td>
                    <td>The drawing mode of the engine either 'textured' for sprite based walls or 'line' for color based walls</td>
                </tr>
            </table></dd>
            <hr>

            <h1><code>void changeFOV(int fov)</code></h1>
            <p>Changes the draw mode of the raycaster</p>
            <h2><dt>Parameters</dt></h2>
            <dd><table>
                <tr>
                    <th>int fov</th>
                    <td>-</td>
                    <td>The field of view in degrees, can be any integer 0-FOV_LIMIT</td>
                </tr>
            </table></dd>
            <hr>
            
            <h1><code>enum DrawMode</code></h1>
            <dd><table>
                <tr>
                    <th>textured</th>
                    <td>-</td>
                    <td>The raycaster will draw walls using sprites in a tilemap</td>
                </tr>
                <tr>
                    <th>line</th>
                    <td>-</td>
                    <td>The raycaster will draw walls using solid colors</td>
                </tr>
            </table></dd>
          </dl>
            
            
        </section>
    </body>
</html>